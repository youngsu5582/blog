<!doctype html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="RabbitMQ VS Kafka" /><meta name="author" content="이영수" /><meta property="og:locale" content="ko" /><meta name="description" content="RabbitMQ와 Kafka 의 차이점과 각 시스템의 특징을 비교하여, 적합한 사용 사례를 제시합니다." /><meta property="og:description" content="RabbitMQ와 Kafka 의 차이점과 각 시스템의 특징을 비교하여, 적합한 사용 사례를 제시합니다." /><link rel="canonical" href="https://youngsu5582.life//posts/rabbitmq-vs-kafka" /><meta property="og:url" content="https://youngsu5582.life//posts/rabbitmq-vs-kafka" /><meta property="og:site_name" content="이영수 개발 블로그" /><meta property="og:image" content="https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-13T21:45:20+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" /><meta property="twitter:title" content="RabbitMQ VS Kafka" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"이영수"},"dateModified":"2025-09-13T21:45:20+09:00","datePublished":"2025-09-13T21:45:20+09:00","description":"RabbitMQ와 Kafka 의 차이점과 각 시스템의 특징을 비교하여, 적합한 사용 사례를 제시합니다.","headline":"RabbitMQ VS Kafka","image":"https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://youngsu5582.life//posts/rabbitmq-vs-kafka"},"url":"https://youngsu5582.life//posts/rabbitmq-vs-kafka"}</script><title>RabbitMQ VS Kafka | 이영수 개발 블로그</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="이영수 개발 블로그"><meta name="application-name" content="이영수 개발 블로그"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/ko.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-GDSPGC31HX"></script> <script> document.addEventListener('DOMContentLoaded', () => { window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-GDSPGC31HX'); }); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">이영수 개발 블로그</a><p class="site-subtitle fst-italic mb-0">Learning Kata</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span></span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/articles/" class="nav-link"> <i class="fa-fw "></i> <span>ARTICLES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/activities/" class="nav-link"> <i class="fa-fw fas fa-walking"></i> <span>ACTIVITIES</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/youngsu5582" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['joyson5582','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href="https://www.linkedin.com/in/%EC%98%81%EC%88%98-%EC%9D%B4-b78498347/" aria-label="linkedin" target="_blank" rel="noopener noreferrer" > <i class="fab fa-linkedin"></i> </a> <a href="https://www.rallit.com/hub/resumes/988543/%EC%9D%B4%EC%98%81%EC%88%98" aria-label="resume" target="_blank" rel="noopener noreferrer" > <i class="fas fa-file-alt"></i> </a> <a href="https://comet-pram-809.notion.site/185365707b6580859ec5ec052f2f6730" aria-label="portfolio" target="_blank" rel="noopener noreferrer" > <i class="fas fa-laptop-code"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"></a> </span> <span>RabbitMQ VS Kafka</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button><style> .language-switcher { display: flex; gap: 10px; list-style: none; margin: 0; padding: 0; } .language-switcher li a { padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; text-decoration: none; color: #333; background-color: #f0f0f0; } .language-switcher li a:hover { background-color: #e0e0e0; } .language-switcher li .active-lang { /* 현재 활성화된 언어 텍스트 스타일 */ padding: 5px 10px; border: 1px solid #007bff; border-radius: 5px; color: white; background-color: #007bff; cursor: default; }</style><ul class="language-switcher"><li> <span class="active-lang">한국어</span><li> <a href="https://youngsu5582.life//en/">English</a></ul><search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel"></button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>RabbitMQ VS Kafka</h1><p class="post-desc fw-light mb-4">RabbitMQ와 Kafka 의 차이점과 각 시스템의 특징을 비교하여, 적합한 사용 사례를 제시합니다.</p><div class="post-meta text-muted"> <span> <time data-ts="1757767520" data-df="DD/MM/YYYY" data-bs-toggle="tooltip" data-bs-placement="bottom" > 13/09/2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" class="popup img-link preview-img shimmer"><img src="/assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8025 " > <em>44 </em> </span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">RabbitMQ VS Kafka</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1"></span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">RabbitMQ VS Kafka</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog> <br><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/rabbitmq/" class="post-tag no-text-decoration" >RabbitMQ</a> <a href="/tags/kafka/" class="post-tag no-text-decoration" >Kafka</a> <a href="/tags/%EB%A9%94%EC%8B%9C%EC%A7%95/" class="post-tag no-text-decoration" >메시징</a> <a href="/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/" class="post-tag no-text-decoration" >비동기</a></div><div class="content"><p><strong>[참고 자료]</strong></p><ul><li><strong>영상:</strong> <a href="https://www.youtube.com/watch?v=w8xWTIFU4C8">[10분 테코톡] 록바의 RabbitMQ vs Kafka</a><li><strong>블로그:</strong><ul><li><a href="https://tech.kakao.com/posts/485">카카오 개발자들을 위한 공용 Message Streaming Platform - Kafka</a><li><a href="https://devconnor.tistory.com/159">RABBITMQ IN DEPTH</a><li><a href="https://medium.com/@greg.shiny82/apache-kafka-%EA%B0%84%EB%9E%B5%ED%95%98%EA%B2%8C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-343ad84a959b">Apache Kafka 간략하게 살펴보기</a></ul></ul><h3 id="서론"><span class="me-2">서론</span><a href="#서론" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>현대 서버 애플리케이션 구조상 메시징 시스템은 필연적이다.</p><p>로직을 분리해 응답 속도 향상, 안정성, 실행 보장, 다른 애플리케이션 서버와 통신 등 목적은 다양할 것이다. 그리고, 많은 개발팀들이 어떤 기술을 사용할 지 고민할것이다.</p><p>나 또한 “우리 팀은 왜 Kafka 가 아닌 RabbitMQ 를 사용할까?” 라는 궁금증에서 시작했고, 그 과정에서 나름대로의 답을 찾은거 같아서 공유하기 위해 작성했다.</p><hr /><h2 id="rabbitmq-smart-broker--dumb-consumer"><span class="me-2">RabbitMQ (Smart Broker &amp; Dumb Consumer)</span><a href="#rabbitmq-smart-broker--dumb-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://i.imgur.com/lKkaONm.png" class="popup img-link shimmer"><img src="https://i.imgur.com/lKkaONm.png" alt="700" loading="lazy"></a></p><p>RabbitMQ는 <strong>AMQP(Advanced Message Queuing Protocol)</strong> 를 구현한 메시지 브로커이며, MQTT 프로토콜도 제공한다. 중심 아이디어는 <strong>브로커(RabbitMQ)가 라우팅, 메시지 보관 및 전달 로직의 대부분을 담당</strong></p><blockquote><p>AMQP? Advanced Message Queueing Protocol: 메시지 지향 미들웨어를 위한 표준 프로토콜 서로 다른 시스템, 애플리케이션이 메시지를 안정적으로 주고 받게 해주는 규약</p><ul><li>상호 운용성: 서로 다른 언어, 플랫폼으로 개발되어도 원활히 통신<li>안정성, 신뢰성: 메시지를 유실되지 않고 안정적으로 전달되는 것을 보장 - 메시지 확인 (ACK), 메시지 영속성, 트랜잭션<li>유연한 라우팅: Exchange 를 통해 라우팅 - 생산자는 Exchange 에 보내고, Exchange 가 설정 규칙에 따라 적절한 큐로 메시지 분배</ul></blockquote><ul><li><strong>Producer (생산자):</strong> 메시지를 생성하여 <strong>Exchange</strong>로 전송<li><strong>Exchange (교환기):</strong> Producer로부터 받은 메시지를 어떤 <strong>Queue</strong>로 보낼지 결정하는 라우팅 규칙의 집합 (메시지 자체를 저장 X)<ul><li><strong>Direct Exchange:</strong> 라우팅 키가 정확히 일치하는 Queue에 메시지 전송 (유니캐스트)<li><strong>Topic Exchange:</strong> 라우팅 키가 특정 패턴에 일치하는 Queue에 메시지 전송 (멀티캐스트)<li><strong>Fanout Exchange:</strong> 자신에게 바인딩된 모든 Queue에 메시지를 전송 (브로드캐스트)<li><strong>Headers Exchange:</strong> 메시지 헤더의 속성을 기반으로 라우팅</ul><li><strong>Queue (큐):</strong> 소비자가 메시지를 가져갈 때까지 메시지를 저장하는 버퍼<li><strong>Binding (바인딩):</strong> Exchange와 Queue를 연결하는 규칙. (<code class="language-plaintext highlighter-rouge">"이 Exchange는 라우팅 규칙에 따라 이 Queue로 메시지를 보내라"</code>)<li><strong>Consumer (소비자):</strong> Queue에서 메시지를 가져와 처리</ul><blockquote><p><strong>핵심 흐름:</strong> Producer → Exchange → (Binding Rule) → Queue → Consumer</p></blockquote><h3 id="스마트-브로커"><span class="me-2">스마트 브로커</span><a href="#스마트-브로커" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>메시지 흐름 완벽 제어: 브로커가 Exchang &amp; Binding 규칙에 따라 메시지 어디로 보낼지 판단 및 라우팅<li>소비자 상태 추적: 컨슈머가 어떤 큐에 연결되어 있는지, 메시지를 제대로 처리했는지 계속 추적<li>메시지를 소비자에게 전송: Push, 브로커가 컨슈머에게 메시지를 전달 - 컨슈머는 prefetch 로 자신이 감당할 수 있는 양만 조절<li>다양한 부가 기능: Dead Letter Exchanges, 메시지 TTL, 우선순위 큐 등등 기능 제공</ul><h3 id="더미-컨슈머"><span class="me-2">더미 컨슈머</span><a href="#더미-컨슈머" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>단순 역할 집중: 컨슈머는 지정된 큐 연결해 브로커가 주는 메시지를 받아 처리하고, 처리 완료 신호만 보냄<li>라우팅 대해 알 필요 없음: 컨슈머는 메시지가 어떤 과정을 거쳐 자신의 큐에 도착하는지 고려할 필요 없음</ul><p>=&gt; 우체국(브로커)이 모든 편지를 분류하고 주소를 알려주며, 집배원(소비자)이 자신의 구역에 할당된 편지를 배달하는 시스템</p><h2 id="kafka-dumb-broker--smart-consumer"><span class="me-2">Kafka (Dumb Broker &amp; Smart Consumer)</span><a href="#kafka-dumb-broker--smart-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://i.imgur.com/GoifRDm.png" class="popup img-link shimmer"><img src="https://i.imgur.com/GoifRDm.png" alt="" loading="lazy"></a></p><p>Kafka는 <strong>분산 스트리밍 플랫폼</strong>이며, 메시지를 <strong>변경 불가능한 로그(immutable log)의 연속된 스트림</strong>으로 취급 브로커는 데이터를 저장하고 관리, 복잡한 라우팅 로직은 소비자가 담당</p><ul><li><strong>Broker (브로커):</strong> Kafka 서버 인스턴스. 메시지를 저장하고 관리하며, 여러 브로커가 모여 <strong>Cluster</strong>를 구성<ul><li>Producer 로부터 메시지 수신, 오프셋 지정해 메시지를 디스크에 저장<li>컨슈머의 파티션 읽기 요청에 응답하고, 디스크에 수록된 메시지 전송<li>한 개는 클러스터의 컨트롤러 역할 수행 - 각 브로커에게 담당 파티션 할당, 브로커 정상 동작하는지 모니터링</ul><li><strong>Cluster (클러스터):</strong> 여러 브로커로 구성되어 데이터 복제, 장애 허용(fault tolerance), 고가용성을 제공<ul><li>클러스터 내 서버 브로커 추가하면, 메시지 수신 및 전달에 대한 처리량 증가<li>시스템 전체 사용에 영향을 주지 않으며, 온라인 상태 수행 가능 ( 소규모 운영 하다가, 트래픽 양에 따라 대규모 늘릴 수 있는 장점 )</ul></ul><p><a href="https://i.imgur.com/rex6S7E.png" class="popup img-link shimmer"><img src="https://i.imgur.com/rex6S7E.png" alt="" loading="lazy"></a></p><ul><li><strong>Topic (토픽):</strong> 메시지를 구분하기 위한 카테고리 또는 피드 이름. RabbitMQ의 Exchange와 유사한 역할이나, 메시지를 직접 저장<ul><li>일종의 DB 테이블, 파일 시스템의 폴더와 유사<li>하나의 토픽은 여러 개의 파티션으로 구성</ul><li><strong>Partition (파티션):</strong> <strong>추가만 가능한(append-only) 로그</strong>이며, 이를 통해 Topic의 데이터를 여러 브로커에 분산하여 저장하고 처리량을 높일 수 있습니다.<ul><li><strong>한 파티션 내에서는 메시지의 순서가 보장됩니다.</strong> - 여러 파티션 간 순서 보장 X</ul></ul><p><a href="https://i.imgur.com/7m78VEq.png" class="popup img-link shimmer"><img src="https://i.imgur.com/7m78VEq.png" alt="" loading="lazy"></a></p><ul><li><strong>Producer (생산자):</strong> 메시지(레코드)를 생성하여 특정 <strong>Topic</strong>으로 전송<li><strong>Consumer (소비자):</strong> Topic에서 메시지를 가져와 처리<ul><li>하나 이상의 토픽 구독, 메시지 생성된 순서대로 읽음 - 파티션 단위로 오프셋 유지해 메시지 위지 파악 가능</ul><li><strong>Offset (오프셋):</strong> 파티션 내에서 각 메시지가 갖는 고유한 순번(ID)입니다. 소비자는 오프셋을 통해 어디까지 메시지를 읽었는지 추적하고 제어<ul><li><strong>Commit Offset</strong>: 컨슈머가 <code class="language-plaintext highlighter-rouge">여기까지 오프셋을 처리했다</code>는 것을 확인하는 오프셋<li><strong>Current Offset</strong>: 컨슈머가 <code class="language-plaintext highlighter-rouge">어디까지 메시지를 읽었는지</code>는 것을 확인하는 오프셋</ul><li><strong>Consumer Group (소비자 그룹):</strong> 하나 이상의 소비자를 묶은 그룹. <strong>하나의 Topic에 대해, 각 파티션은 소비자 그룹 내의 단 하나의 소비자에게만 할당</strong><ul><li>각 컨슈머가 해당 토픽의 다른 파티션을 분담해서 메시지 읽을 수 있음<li>컨슈머를 추가하면, 메시지 소비 성능 확장</ul></ul><blockquote><p>하나의 토픽 내 파티션 개수보다 더 많은 컨슈머를 추가하는게 의미 없음</p></blockquote><blockquote><p><strong>핵심 흐름:</strong> Producer → Topic (Partition) → Consumer (Consumer Group)</p></blockquote><h3 id="더미-브로커"><span class="me-2">더미 브로커</span><a href="#더미-브로커" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>고성능 파일 저장소 역할에 집중: 브로커는 메시지를 받아서 토픽 파티션 끝에 빠르게 추가, 디스크에 저장<li>메시지 상태 추적 X: 브로커는 어떤 소비자가 어떤 메시지를 읽었는지 고려 X, 그냥 설정된 보존 기간 동안 저장<li>복잡한 라우팅 X: 메시지 받으면 생산자가 지정한 토픽 / 파티션에 저장, 브로커가 자체적 메시지 재분배 X</ul><h3 id="스마트-컨슈머"><span class="me-2">스마트 컨슈머</span><a href="#스마트-컨슈머" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>읽을 위치를 직접 관리: 컨슈머가 자신이 토픽의 어떤 파티션에서 몇 번째 메시지까지 읽었는지 스스로 기록 &amp; 관리<li>데이터를 직접 당겨옴: Pull, 컨슈머가 브로커에게 능동적으로 요청해서 데이터를 가져옴<li>파티션 할당 로직 담당: 소비자 그룹 내 어떤 파티션을 담당할지 결정 로직도 소비자가 속한 클라이언트 라이브러리에서 처리</ul><p>=&gt; 거대한 도서관 (브로커) 은 책 (메시지) 을 책장 (파티션) 에 계속 꽂아두기만 할 뿐 독자 (소비자) 가 직접 도서관 찾아와 자기가 읽을 부분 (오프셋) 을 기억하고, 다음 읽을 책도 꺼내가는 형태</p><blockquote><p>Gemini 비유 좋다…!</p></blockquote><h2 id="흔한-오해들"><span class="me-2">흔한 오해들</span><a href="#흔한-오해들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>두 개가 구조가 비슷하고, 성능만 차이 난다고 오해를 할 수 있는데 (또는, RabbitMQ 가 사용하지 않는 메시징 시스템이라던가…) 이 개념들을 명확히 이해해야 두 시스템의 아키텍처 철학 차이를 제대로 파악할 수 있다.</p><blockquote><p>팬아웃: 하나의 메시지를 여러 독립적 소비자가 각각 동일한 복사본 받아 처리하는 패턴</p><h3 id="1-kafka의-팬아웃은-단순한-전파broadcast가-아니다"><span class="me-2">1. Kafka의 ‘팬아웃’은 단순한 전파(Broadcast)가 아니다</span><a href="#1-kafka의-팬아웃은-단순한-전파broadcast가-아니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></blockquote><p>가장 흔한 오해 중 하나는 <code class="language-plaintext highlighter-rouge">Kafka는 Pub/Sub</code>, <code class="language-plaintext highlighter-rouge">RabbitMQ는 Work-Queue</code>라는 이분법적 시각이다. 사실 Kafka는 이 두 가지 모델을 <strong>소비자 그룹(Consumer Group)</strong> 이라는 개념을 통해 우아하게 통합해준다고 한다.</p><ul><li><p><strong>그룹 간(Inter-Group)에는 Pub/Sub (팬아웃/방송):</strong> 서로 <strong>다른 소비자 그룹</strong>은 같은 토픽을 구독하더라도 메시지 스트림 전체를 독립적으로 소비한다. EX) <code class="language-plaintext highlighter-rouge">order-events</code>라는 토픽이 있을 때, <code class="language-plaintext highlighter-rouge">재고 관리 서비스</code>(그룹 A)와 <code class="language-plaintext highlighter-rouge">데이터 분석 팀</code>(그룹 B) 등 각각 별개의 소비자 그룹으로 구독이 가능하다. 이 경우, 두 그룹 모두 <code class="language-plaintext highlighter-rouge">order-events</code>의 모든 메시지를 처음부터 끝까지 받고 개별적으로 처리할 수 있다.</p><li><p><strong>그룹 내(Intra-Group)에서는 Work-Queue (분산 처리):</strong> 단, 하나의 <strong>같은 소비자 그룹 내</strong>에서는 이야기가 달라진다. 그룹에 속한 소비자가 토픽의 파티션(Partition)들을 나누어 처리한다. (<strong>하나의 파티션은 그룹 내 단 하나의 소비자에게만 할당</strong>) 만약 토픽에 4개의 파티션이 있고, 그룹에 4개의 소비자가 있다면, 각 소비자는 하나의 파티션을 전담하여 메시지를 처리한다. -&gt; 이는 작업 부하를 분산하고 처리량을 높이는 ‘워크큐’ 모델과 동일하게 처리</p></ul><blockquote><p><strong>핵심:</strong> Kafka는 <strong>소비자 그룹</strong>을 통해 <strong>서로 다른 시스템 간에는 데이터를 복제/방송</strong>하고, <strong>단일 시스템 내에서는 작업을 분산</strong>하여 처리량을 극대화하는 두 가지 방식 모두 적용</p></blockquote><h3 id="2-메시지-보존retention-철학-로그인가-큐인가"><span class="me-2">2. 메시지 보존(Retention) 철학: ‘로그’인가, ‘큐’인가?</span><a href="#2-메시지-보존retention-철학-로그인가-큐인가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>두 시스템의 가장 근본적인 차이는 메시지를 다루는 방식이다.</p><ul><li><p><strong>Kafka: 데이터는 ‘변경 불가능한 로그(Immutable Log)’</strong> Kafka는 소비자가 메시지를 읽어가도 <strong>즉시 삭제하지 않는다.</strong> 메시지는 설정된 보존 기간(예: 7일) 또는 용량에 도달할 때까지 토픽에 안전하게 보관한다. 소비자는 단지 ‘어디까지 읽었는지’를 나타내는 <strong>오프셋(Offset)</strong> 만 관리한다.</p><ul><li><strong>메시지 재생(Replay) &amp; 시간 여행:</strong><ul><li>소비자에 버그가 있었다면? 코드를 수정한 뒤, 오프셋을 과거 시점으로 되돌려 모든 데이터를 다시 처리할 수 있다.<li>메시지를 사용하는 새로운 시스템을 도입했다면? 토픽의 처음부터 모든 이벤트를 가져와 상태를 재구축할 수 있다.</ul><li><strong>다목적 데이터 허브:</strong> 하나의 이벤트 스트림을 실시간 대시보드, 배치(Batch) 분석, 모델 학습 등 다양한 목적을 가진 여러 소비자가 각자의 속도에 맞게 여러 번 소비할 수 있다.</ul><li><p><strong>RabbitMQ: 데이터는 ‘처리해야 할 일(Transient Task)’</strong> 전통적인 RabbitMQ에서 메시지는 ‘처리되어야 할 작업’. 소비자가 메시지를 가져가 성공적으로 처리했다고 <strong>확인(ack) 신호</strong>를 보내면, 메시지는 <strong>큐에서 영구적으로 제거된다.</strong></p><p>이 방식 특징:</p><ul><li><strong>작업 큐에 최적화:</strong> <code class="language-plaintext highlighter-rouge">이메일을 보내라</code>, <code class="language-plaintext highlighter-rouge">이미지를 생성해라</code> ,<code class="language-plaintext highlighter-rouge">"이미지를 최적화해라"</code> 와 같이 한 번 처리되고 나면 더 이상 필요 없는 작업들을 관리하는 데 매우 효율적이다.<li><strong>오류 처리 중심의 보관:</strong> 메시지 TTL(Time-To-Live)이나 Dead Letter Exchange(DLX)는 메시지가 <em>성공적으로 처리되지 못했을 때</em>를 대비한 기능이다. (즉, 영구 보존이 아닌 예외 처리 및 재시도 로직을 위한 장치)</ul></ul><blockquote><p><strong>참고:</strong> RabbitMQ도 시대의 흐름에 맞춰 <strong>Streams</strong>라는 새로운 큐 타입을 도입. (Kafka처럼 오프셋 기반의 비파괴 소비를 지원하여 로그와 같은 동작을 유사) 하지만 RabbitMQ 는 기본적으로 ‘소비-제거’ 방식의 큐를 위해 사용한다.</p></blockquote><h3 id="3-rabbitmq의-팬아웃은-교환기exchange의-역할"><span class="me-2">3. RabbitMQ의 팬아웃은 ‘교환기(Exchange)’의 역할</span><a href="#3-rabbitmq의-팬아웃은-교환기exchange의-역할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RabbitMQ도 팬아웃의 방식은 Kafka와는 다르다. RabbitMQ의 라우팅 능력의 핵심에는 <strong>교환기(Exchange)</strong> 를 통해 수행한다.</p><p>생산자는 메시지를 큐에 직접 보내는 것이 아니라, 교환기에 보낸다. 그러면 교환기가 설정된 타입과 규칙에 따라 메시지를 어떤 큐에 보낼지 결정한다.</p><ul><li><strong><code class="language-plaintext highlighter-rouge">fanout</code> 교환기:</strong> 자신에게 연결(binding)된 <strong>모든 큐</strong>에 메시지를 복사해서 보낸다. 가장 순수한 형태의 방송(Broadcast) 모델<li><strong><code class="language-plaintext highlighter-rouge">topic</code> 교환기:</strong> 라우팅 키와 바인딩 패턴을 와일드카드(<code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">#</code>)로 매칭, 조건에 맞는 큐에만 메시지를 선택해서 보낸다. (멀티캐스트)<li><strong><code class="language-plaintext highlighter-rouge">direct</code> 교환기:</strong> 라우팅 키가 바인딩 키와 정확히 일치하는 큐에만 메시지를 보냅니다. (유니캐스트)</ul><blockquote><p><strong>핵심:</strong> RabbitMQ에서는 <strong>브로커(교환기)가 ‘스마트’하게 라우팅 규칙을 해석</strong>하여 메시지를 분배 반면 Kafka에서는 <strong>생산자가 토픽을 지정</strong>하고, <strong>소비자가 ‘스마트’하게 그룹을 지어</strong> 메시지를 가져간다.</p></blockquote><hr /><h2 id="rabbitmq-vs-kafka-7가지-핵심-비교-포인트"><span class="me-2">RabbitMQ vs Kafka: 7가지 핵심 비교 포인트</span><a href="#rabbitmq-vs-kafka-7가지-핵심-비교-포인트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이제 두 시스템의 구체적인 기능과 특성을 7가지 핵심 주제로 나누어 깊이 있게 비교해보자.</p><h3 id="1-메시지-보존--재생replay-데이터에-대한-관점-차이"><span class="me-2">1. 메시지 보존 &amp; 재생(Replay): 데이터에 대한 관점 차이</span><a href="#1-메시지-보존--재생replay-데이터에-대한-관점-차이" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: 영구적인 로그, 무한한 재생 가능성</strong></ul><p><a href="https://i.imgur.com/ygKoOrU.png" class="popup img-link shimmer"><img src="https://i.imgur.com/ygKoOrU.png" alt="1000" loading="lazy"></a></p><ul><li><p><strong>철학:</strong> Kafka는 데이터를 ‘일시적인 메시지’가 아닌 ‘영구적인 사실의 기록(log of facts)’으로 취급한다. 메시지는 소비되어도 삭제되지 않고 <code class="language-plaintext highlighter-rouge">retention.ms</code> (시간) 또는 <code class="language-plaintext highlighter-rouge">retention.bytes</code> (용량) 설정에 따라 디스크에 보관된다.</p><ul><li><strong>오프셋 리셋 (재생):</strong> 소비자는 언제든지 <code class="language-plaintext highlighter-rouge">auto.offset.reset = 'earliest'</code> 설정을 하면 토픽의 가장 처음부터 모든 이벤트를 다시 읽어올 수 있다. (이는 버그 수정 후 데이터 복구, 새로운 서비스의 상태 구축, A/B 테스팅 등 무한한 방법을 가능하게 해준다)<li><strong>로그 컴팩션 (Log Compaction):</strong> <code class="language-plaintext highlighter-rouge">cleanup.policy=compact</code>로 설정하면, Kafka는 토픽의 모든 메시지를 보관하지 않고 <strong>각 메시지 키(key)에 대한 가장 최신 값만</strong>을 유지한다.<blockquote><p><a href="https://docs.confluent.io/kafka/design/log_compaction.html">Kafka Log Compaction</a> 내용을 참고</p></blockquote></ul><li><p><strong>RabbitMQ: 소비 후 제거되는 작업 큐</strong></p><ul><li><strong>철학:</strong> RabbitMQ의 기본 모델은 ‘처리해야 할 작업’을 큐에 넣고, 작업이 완료되면(<code class="language-plaintext highlighter-rouge">ack</code>) 큐에서 제거한다. (데이터 보존보다 안정적인 작업 전달에 초점을 맞춘다)<li><strong>제한적인 재생:</strong> 메시지가 <code class="language-plaintext highlighter-rouge">ack</code>되면 사라지므로 Kafka와 같은 자유로운 재생이 불가능하다. 오류 발생 시 메시지를 재처리하기 위해 <strong>Dead Letter Exchange (DLX)</strong> 로 보내거나, 소비자가 <code class="language-plaintext highlighter-rouge">nack</code> (또는 <code class="language-plaintext highlighter-rouge">reject</code>)하여 큐에 다시 넣는 방식을 사용한다.<li><strong>스트림 큐 (Streams):</strong> RabbitMQ 3.9부터 도입된 <strong>스트림 큐</strong>는 Kafka와 유사한 로그 기반 동작을 제공한다. 메시지를 삭제하지 않고 오프셋을 통해 추적해, 비파괴적인 소비와 대용량 데이터의 팬아웃이 가능하다. (하지만 이는 RabbitMQ의 전통적인 모델을 보완하는 기능이며, 생태계는 당연히 Kafka가 더 성숙)</ul></ul><h3 id="2-순서ordering--병렬성-보장과-트레이드오프"><span class="me-2">2. 순서(Ordering) &amp; 병렬성: 보장과 트레이드오프</span><a href="#2-순서ordering--병렬성-보장과-트레이드오프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: 파티션 단위의 엄격한 순서 보장</strong><ul><li><strong>동작 방식:</strong> Kafka는 <strong>하나의 파티션 내 메시지의 순서를 절대적으로 보장</strong> 한다. 생산자가 보낸 순서대로 메시지가 로그에 기록되고, 소비자는 그 순서대로 읽는다.<li><strong>병렬성과 순서의 트레이드오프:</strong> 처리량을 높이기 위해 파티션 수를 늘리면 병렬 처리 수준은 높아지나, 서로 다른 파티션 간의 순서는 보장되지 않는다.<li><strong>키 기반 파티셔닝:</strong> 순서 보장이 중요한 경우, <strong>메시지 키(key)</strong> 를 통해 보장해야 한다 (예를 들어, 모든 <code class="language-plaintext highlighter-rouge">user_id</code> 관련 이벤트를 동일한 <code class="language-plaintext highlighter-rouge">user_id</code>를 키로 전송하면, Kafka는 해시 값을 계산해 항상 동일한 파티션으로 해당 이벤트를 보낸다. - 모든 이벤트 순서대로 처리)</ul><li><strong>RabbitMQ: 경쟁적 소비자 환경에서의 순서 불확실성</strong><ul><li><strong>기본 동작:</strong> 큐 자체는 FIFO(First-In-First-Out) 구조를 따르지만, 여러 소비자가 하나의 큐를 동시에 구독해 경쟁적으로 메시지를 가져가면, <strong>메시지 처리 순서는 보장되지 않는다.</strong> EX) 소비자 A가 메시지 1을, 소비자 B가 메시지 2를 거의 동시에 가져가고 만약 소비자 A의 작업이 오래 걸리고 소비자 B가 먼저 작업을 끝내면, 메시지 2가 메시지 1보다 먼저 처리될 수 있다.<li><strong>순서 보장 방법:</strong> 큐에 단 하나의 소비자만 활성화하여 순서를 강제할 순 있다. ( 병렬성을 포기하므로, 당연히 생산성 감소 )<blockquote><p>RabbitMQ 로 순서를 제어하는건 생각보다 꽤나 어렵다.. 메시지를 기반으로 다음 메시지를 연쇄적으로 발행시키는 방법으로 순서를 보장하자.</p></blockquote></ul></ul><h3 id="3-전달-보장delivery-semantics-데이터-유실-및-중복에-대한-약속"><span class="me-2">3. 전달 보장(Delivery Semantics): 데이터 유실 및 중복에 대한 약속</span><a href="#3-전달-보장delivery-semantics-데이터-유실-및-중복에-대한-약속" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Exactly-Once (정확히 한 번 전달) 지원</strong><ul><li><strong>At-least-once (최소 한 번):</strong> 기본 설정. 소비자가 메시지를 처리하고 오프셋을 커밋하기 전에 실패하면, 재연결 후 마지막 커밋된 오프셋부터 다시 메시지를 읽어 중복이 발생할 수 있다.<li><strong>Exactly-Once (EOS):</strong> Kafka 0.11부터 <strong>멱등성 프로듀서(Idempotent Producer)</strong>와 <strong>트랜잭션(Transactions)</strong> 을 조합하여 EOS를 지원한다.<ul><li><strong>멱등성 프로듀서:</strong> 네트워크 오류 등으로 재시도를 하더라도, 각 메시지에 부여된 고유 ID를 통해 브로커가 중복을 제거한다.<li><strong>트랜잭션:</strong> 여러 토픽/파티션에 걸친 여러 메시지 쓰기 작업을 하나의 원자적 단위로 묶어, ‘읽기-처리-쓰기’ 패턴으로 완벽한 EOS를 가능하게 해준다.<blockquote><p><strong>[참고 자료] Kafka의 Exactly-Once 심층 분석:</strong> <a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/">Exactly-Once Semantics Are Possible: Here’s How Kafka Does It</a> 내용 참고</p></blockquote></ul></ul><li><strong>RabbitMQ: At-least-once가 기본, Exactly-once는 애플리케이션의 몫</strong><ul><li><strong>At-least-once (최소 한 번):</strong> 소비자가 메시지를 처리하고 브로커에게 <code class="language-plaintext highlighter-rouge">ack</code>를 보내기 전에 연결이 끊어지면, 브로커는 해당 메시지를 다른 소비자에게 다시 전달하여 중복이 발생할 수 있다.<li><p><strong>At-most-once (최대 한 번):</strong> <code class="language-plaintext highlighter-rouge">auto-ack</code> 모드를 사용하면, 소비자가 메시지를 받는 즉시 브로커가 <code class="language-plaintext highlighter-rouge">ack</code>된 것으로 간주한다. 만약 소비자가 메시지를 처리하던 중 실패하면 해당 메시지는 유실된다. (서비스 특성에 따라 주의깊게 사용)</p><li><strong>Exactly-once의 부재:</strong> RabbitMQ는 프로토콜/브로커 수준에서 EOS를 직접 지원하지 않는다. EOS를 구현하려면, 소비자가 직접 <strong>멱등성 로직</strong>을 구현해야 한다.</ul></ul><blockquote><p>근데, At-least-once 가 전혀 나쁜 설정이 아니다. 왜냐하면, 소비자가 원한 특정 로직을 무조건 해줘야 할 필요가 있는데 특정 컨슈머가 처리 못해도 다른 컨슈머가 무조건 처리해주는 걸 보장해줄 수 있기 때문이다. 데이터 처리한 내용을 DB 에 반영하는건, 다른 DB 가 다른 메시지로 처리해주면 된다.</p></blockquote><h3 id="4-흐름-제어--백프레셔-누가-속도를-제어하는가"><span class="me-2">4. 흐름 제어 &amp; 백프레셔: 누가 속도를 제어하는가?</span><a href="#4-흐름-제어--백프레셔-누가-속도를-제어하는가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Pull 기반 (소비자가 주도)</strong><ul><li><strong>철학:</strong> 소비자가 자신의 처리 능력에 맞게 브로커의 데이터를 <strong>당겨온다(Pull)</strong>. 소비자가 <code class="language-plaintext highlighter-rouge">poll()</code> 메소드를 호출할 때만 데이터 전송<li><strong>백프레셔:</strong> 이 모델 자체가 백프레셔. 소비자가 바쁘면 <code class="language-plaintext highlighter-rouge">poll()</code>을 호출하지 않고, 데이터는 브로커에서 대기한다. (<code class="language-plaintext highlighter-rouge">max.poll.records</code> (한 번에 가져올 최대 메시지 수), <code class="language-plaintext highlighter-rouge">fetch.min.bytes</code> (최소 이만큼 데이터가 쌓여야 응답) 등 옵션으로 소비 속도를 세밀하게 튜닝 가능)</ul><li><strong>RabbitMQ: Push 기반 (브로커가 주도) + Prefetch</strong><ul><li><strong>철학:</strong> 브로커가 소비자에게 메시지를 <strong>밀어준다(Push)</strong>. 소비자가 준비되었는지 여부와 상관없이 메시지를 보내므로, 소비자가 압도당할 위험 존재<li><strong>백프레셔 (Prefetch):</strong> 이 문제를 해결하기 위해 소비자는 <strong><code class="language-plaintext highlighter-rouge">prefetch</code> 값(QoS - Quality of Service)</strong> 을 설정. 브로커는 해당 소비자가 처리 중인 메시지 수가 <code class="language-plaintext highlighter-rouge">prefetch</code> 값에 도달하면 더 이상 메시지를 보내지 않고 대기.</ul></ul><blockquote><p>RabbitMQ에서 <code class="language-plaintext highlighter-rouge">prefetch</code> 값 설정은 성능과 안정성에 매우 중요. 너무 작으면 네트워크 왕복이 잦아져 처리량이 낮아지고, 너무 크면 소비자의 메모리가 고갈 가능 ( 특이한 도메인은 메시지를 무조건 하나씩 받아야 할 수 있다. - AI 이미지 생성 로직이라면 GPU 를 쓰고 한번에 하나의 작업만 보장하기 위해 prefetch 1 )</p></blockquote><h3 id="5-라우팅토폴로지-스마트-브로커-vs-더미-브로커"><span class="me-2">5. 라우팅/토폴로지: ‘스마트 브로커’ vs ‘더미 브로커’</span><a href="#5-라우팅토폴로지-스마트-브로커-vs-더미-브로커" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>위에서 이미 작성한 내용이라 간단하게만 작성한다.</p></blockquote><ul><li><strong>Kafka: 단순한 토폴로지, 스마트한 클라이언트</strong><ul><li><strong>더미 브로커:</strong> Kafka 브로커의 역할은 단순. 생산자가 지정한 토픽의 파티션에 메시지를 순서대로 저장. (복잡한 라우팅 로직 X)<li><strong>스마트 클라이언트:</strong> 라우팅 결정은 주로 <strong>생산자</strong>가 담당. 어떤 토픽으로, 어떤 키를 사용해 어느 파티션으로 보낼지를 결정. 소비자는 어떤 토픽을 구독할지 결정.</ul><li><strong>RabbitMQ: 유연한 라우팅, 스마트한 브로커</strong><ul><li><strong>스마트 브로커:</strong> RabbitMQ 은 <strong>교환기(Exchange)</strong> 를 통해 스마트하게 처리한다. 생산자는 메시지를 교환기에 보내고, 교환기는 설정된 타입(<code class="language-plaintext highlighter-rouge">direct</code>, <code class="language-plaintext highlighter-rouge">topic</code>, <code class="language-plaintext highlighter-rouge">fanout</code>, <code class="language-plaintext highlighter-rouge">headers</code>)과 라우팅 규칙(<code class="language-plaintext highlighter-rouge">binding</code>)에 따라 메시지를 적절한 큐로 분배<li><strong>복잡한 워크플로우 구현:</strong> 이 모델을 통해 메시지 내용에 따라 다른 큐로 보내거나, 여러 큐에 동시에 보내는 등 정교하고 복잡한 워크플로우를 브로커 수준에서 쉽게 구현할 수 있다. (<strong>Dead Letter Exchange</strong>, <strong>Delayed Message Plugin</strong> 등을 조합해 재시도, 지연 처리 등 고급 패턴도 가능)</ul></ul><h3 id="6-확장성--고가용성ha-스케일-아웃과-데이터-복제"><span class="me-2">6. 확장성 &amp; 고가용성(HA): 스케일 아웃과 데이터 복제</span><a href="#6-확장성--고가용성ha-스케일-아웃과-데이터-복제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: 파티션 기반의 완벽한 수평 확장</strong><ul><li><strong>설계:</strong> Kafka는 처음부터 분산 시스템으로 설계. 토픽을 여러 파티션으로 나누고, 이 파티션들을 클러스터 내 여러 브로커에 분산해 읽기/쓰기 부하를 수평으로 확장(scale-out) 가능<li><strong>고가용성 (HA):</strong> 각 파티션은 <strong>복제 계수(Replication Factor)</strong> 를 가진다.<ul><li>파티션 중 하나는 <strong>리더(Leader)</strong> 가 되어 읽기/쓰기를 담당, 나머지는 <strong>팔로워(Follower)</strong> 가 되어 리더의 데이터를 복제<li>리더 브로커에 장애가 발생하면, 팔로워 중 하나가 자동으로 새로운 리더로 선출되어 서비스 중단을 최소화 - failover</ul></ul><li><strong>RabbitMQ: Quorum 큐와 스트림을 통한 현대적인 HA</strong><ul><li><strong>Mirrored Queues:</strong> 과거에는 미러 큐를 사용했지만, 리더-팔로워 모델의 한계와 데이터 안정성 문제로 인해 현재는 권장되지 않습니다.<li><strong>Quorum Queues:</strong> RabbitMQ 3.8부터 도입된 쿼럼 큐는 <strong>Raft 합의 알고리즘</strong>을 기반으로 동작합니다. 이는 모든 메시지 복제가 클러스터의 과반수 노드에 기록되었음을 보장하여 미러 큐보다 훨씬 높은 데이터 안정성을 제공합니다. 고가용성과 데이터 안전이 중요한 대부분의 경우에 권장됩니다.<li><strong>스트림 큐 (Streams):</strong> 대용량 처리량과 수평 확장이 필요할 때 사용됩니다. 스트림은 여러 브로커에 걸쳐 샤딩(sharding)될 수 있어 Kafka와 유사한 확장성을 제공합니다.</ul></ul><blockquote><p>리더 -팔로워 모델의 문제?</p><ul><li>쓰기 병목: 메시지 발행하면 무조건 리더 큐에 먼저 도달, 팔로워들이 메시지 복제하고 확인 응답 보낼때 까지 대기<li>읽기 병목:소비자는 리더 큐에만 연결해서 메시지 가져올 수 있음 =&gt; 발행과 소비 트래픽이 하나의 리더 노드에 몰리게 된다.</ul></blockquote><h3 id="7-생태계--도구-플랫폼-vs-브로커"><span class="me-2">7. 생태계 &amp; 도구: ‘플랫폼’ vs ‘브로커’</span><a href="#7-생태계--도구-플랫폼-vs-브로커" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: 데이터 파이프라인 플랫폼</strong> Kafka는 단순한 메시지 브로커를 넘어, 그 자체로 하나의 거대한 데이터 플랫폼을 형성<ul><li><strong>Kafka Connect:</strong> 데이터베이스, S3, Elasticsearch 등 수백 개의 시스템과 Kafka를 코딩 없이 연결하는 프레임워크.<li><strong>Kafka Streams / ksqlDB:</strong> Kafka 토픽 데이터를 실시간으로 처리하고 분석하는 스트림 처리 라이브러리 및 SQL 엔진.<li><strong>Schema Registry:</strong> 데이터의 스키마를 관리하고 발전시켜, 데이터 일관성과 호환성을 보장</ul><li><strong>RabbitMQ: 다재다능한 메시지 브로커</strong> RabbitMQ는 특정 목적에 맞춰 유연하게 사용할 수 있는 강력한 브로커 의 느낌<ul><li><strong>Management UI:</strong> 큐 상태, 메시지 흐름, 연결 등을 시각적으로 모니터링하고 관리할 수 있는 훌륭한 웹 UI를 기본 제공<li><strong>Federation / Shovel:</strong> 서로 다른 데이터 센터나 환경에 있는 브로커들을 연결하는 강력한 플러그인<li><strong>다양한 프로토콜 지원:</strong> AMQP 0-9-1, AMQP 1.0, STOMP, MQTT 등 다양한 프로토콜을 플러그인을 통해 지원해 유연성이 높음</ul></ul><h2 id="언제-무엇을-고를까"><span class="me-2">언제 무엇을 고를까..?</span><a href="#언제-무엇을-고를까" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>AI 가 요약해 준 내용이자, 팀에서 RabbitMQ 를 왜 쓰는가에 대해 고민할 때 이정도로 생각난 내용으로 당연히 틀릴 내용일 수 있다.</p></blockquote><ul><li><strong>“과거 데이터를 다시 처리해야 하는 경우가 있는가?”</strong><ul><li><strong>Yes → Kafka:</strong> 이벤트 소싱, 데이터 분석, 새로운 서비스 도입 시 상태 재구축 등 데이터 재생이 필요하다면 무조건 Kafka</ul><li><strong>“메시지마다 복잡한 조건에 따라 다른 곳으로 보내야 하는가?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> 메시지 헤더나 라우팅 키 패턴에 따라 정교하게 라우팅하는 기능이 필요하다면 RabbitMQ - 스마트 브로커</ul><li><strong>“주된 용도가 백그라운드에서 실행될 비동기 작업을 처리하는 것인가?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> 이메일 발송, 이미지 처리 등 전통적인 ‘작업 큐’ 시나리오에서는 RabbitMQ - 간단하고, 직관적인 해결책 ( 메시지 유지할 필요도 없기에 )</ul><li><strong>“수많은 독립적인 서비스들이 동일한 이벤트 스트림을 각자의 목적에 맞게 소비해야 하는가?”</strong><ul><li><strong>Yes → Kafka:</strong> 여러 팀, 서비스가 각자의 속도로 동일 데이터를 소비하는 ‘데이터 허브’ 또는 ‘이벤트 백본’을 구축하는 경우 - 소비자 그룹 모델과 메시지 보존 정책</ul><li><strong>“초당 수십만 건 이상의 매우 높은 처리량이 필수적인가?”</strong><ul><li><strong>Yes → Kafka:</strong> Kafka는 디스크 기반의 순차 I/O를 활용하여 대규모 스트림 데이터를 처리하는 데 최적화 - Append-Only, OS 레벨 페이지 캐시, Zero-Copy 기술 활용</ul><li><strong>“메시지별 TTL, 지연 처리, 요청-응답(RPC) 패턴이 필요한가?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> RabbitMQ는 이러한 고급 메시징 패턴들을 플러그인 등을 통해 더 성숙하게 지원</ul></ul><h2 id="마무리"><span class="me-2">마무리</span><a href="#마무리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>꼭 메시지 큐잉 시스템을 Kafka 로 써야한다고 생각에 빠지지 말자. 회사 인프라, 팀 내 기술, 프로젝트 내 요구사항 등 다양한 것들이 고려되어 결정이 되어야 한다.</p><p>우리팀의 메시지 큐잉 시스템은</p><ul><li>AI 생성 로직이 API 서버와 분리 되기 위해서 사용<li>작업이 무조건 수행 되는걸 보장<li>아직 대용량의 처리 및 시스템을 구축할 필요가 없는점 + 리플레이 및 메시지를 저장할 필요가 없는점</ul><p>이런점들을 통해 RabbitMQ 를 사용한다고 생각한다.</p></div><div class="post-tail-wrapper text-muted"><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"></div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted"></span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=RabbitMQ%20VS%20Kafka%20-%20%EC%9D%B4%EC%98%81%EC%88%98%20%EA%B0%9C%EB%B0%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8&url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka&text=RabbitMQ%20VS%20Kafka%20-%20%EC%9D%B4%EC%98%81%EC%88%98%20%EA%B0%9C%EB%B0%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Linkedin" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="" data-title-succeed="" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading"></h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/rabbitmq-vs-kafka">RabbitMQ VS Kafka - 2025-09-13</a><li class="text-truncate lh-lg"> <a href="/posts/partitioning-in-postgresql/">파티셔닝 톺아보기 in PostgreSQL - 2025-09-07</a><li class="text-truncate lh-lg"> <a href="/posts/ai-tech-usage-summary-thoughts-ko/">개발자라면 꼭 알아야 할 AI 기술 활용법 영상 정리 및 간단한 사담 - 2025-08-20</a><li class="text-truncate lh-lg"> <a href="/posts/%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-Jackson-%EC%84%A4%EC%A0%95%EB%93%A4-%EC%A0%95%EB%A6%AC/">사용하는 Jackson의 설정 및 기능 정리 - 2025-06-17</a><li class="text-truncate lh-lg"> <a href="/posts/%EC%98%88%EC%99%B8-%EA%B9%8A%EA%B2%8C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-%EC%98%88%EC%99%B8-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%8D%98%EC%A7%80%EA%B8%B0/">예외 깊게 살펴보기, 예외 동적으로 던지기 - 2025-05-31</a></ul></section><section><h2 class="panel-heading"></h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9A%B0%ED%85%8C%EC%BD%94/">우테코</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%8A%A4%ED%94%84%EB%A7%81/">스프링</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83%ED%97%88%EB%B8%8C/">깃허브</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/git/">git</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83/">깃</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/">비동기</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/">코틀린</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0"></h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label"></h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/%EC%99%B8%EB%B6%80%EA%B9%83%ED%97%88%EB%B8%8C-%ED%98%B8%EC%B6%9C%EC%9D%84-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%A1%9C-30-%EA%B0%80%EB%9F%89-%EB%B9%A0%EB%A5%B4%EA%B2%8C2-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%8A%9C%EB%8B%9D-%EC%B8%A1%EC%A0%95/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731167794" data-df="DD/MM/YYYY" > 10/11/2024 </time><h4 class="pt-0 my-2">외부(깃허브) 호출을 비동기로 30% 가량 빠르게(2) - 스레드 튜닝, 측정</h4><div class="text-muted"><p>스레드 튜닝과 성능 측정 방법</p></div></div></a></article><article class="col"> <a href="/posts/%EC%99%B8%EB%B6%80-API-%ED%98%B8%EC%B6%9C%EC%9D%84-30-%EA%B0%80%EB%9F%89-%EB%B9%A0%EB%A5%B4%EA%B2%8C1-%EA%B8%B0%EB%B3%B8-%EB%A1%9C%EC%A7%81/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731146166" data-df="DD/MM/YYYY" > 09/11/2024 </time><h4 class="pt-0 my-2">외부 API 호출을 30% 가량 빠르게(1) - 기본 로직</h4><div class="text-muted"><p>API 호출 시간을 딸깍 하고 싶은자 BE동기로...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/partitioning-in-postgresql/" class="btn btn-outline-primary" aria-label="" ><p>파티셔닝 톺아보기 in PostgreSQL</p></a><div class="btn btn-outline-primary disabled" aria-label=""><p>-</p></div></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/youngsu5582">이영수</a>.</p><p></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading"></h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9A%B0%ED%85%8C%EC%BD%94/">우테코</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%8A%A4%ED%94%84%EB%A7%81/">스프링</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83%ED%97%88%EB%B8%8C/">깃허브</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/git/">git</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83/">깃</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/">비동기</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/">코틀린</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><script> (function () { const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed'); const initTheme = themeMapper[Theme.visualState]; let lang = 'ko';if (lang.length > 2 && !lang.startsWith('zh')) { lang = lang.slice(0, 2); } let giscusAttributes = { src: 'https://giscus.app/client.js', 'data-repo': 'youngsu5582/blog', 'data-repo-id': 'R_kgDOOI2eig', 'data-category': 'Post', 'data-category-id': 'DIC_kwDOOI2eis4Cob3Y', 'data-mapping': 'pathname', 'data-strict' : '0', 'data-reactions-enabled': '1', 'data-emit-metadata': '0', 'data-theme': initTheme, 'data-input-position': 'bottom', 'data-lang': lang, 'data-loading': 'lazy', crossorigin: 'anonymous', async: '' }; let giscusNode = document.createElement('script'); Object.entries(giscusAttributes).forEach(([key, value]) => giscusNode.setAttribute(key, value) ); const $footer = document.querySelector('footer'); $footer.insertAdjacentElement("beforebegin", giscusNode); addEventListener('message', (event) => { if (event.source === window && event.data && event.data.id === Theme.ID) { const newTheme = themeMapper[Theme.visualState]; const message = { setConfig: { theme: newTheme } }; const giscus = document.getElementsByClassName('giscus-frame')[0].contentWindow; giscus.postMessage({ giscus: message }, 'https://giscus.app'); } }); })(); </script> <script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
