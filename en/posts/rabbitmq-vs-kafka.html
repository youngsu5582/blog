<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="RabbitMQ VS Kafka" /><meta name="author" content="Youngsoo Lee" /><meta property="og:locale" content="en" /><meta name="description" content="This post compares the differences and characteristics of RabbitMQ and Kafka and suggests suitable use cases." /><meta property="og:description" content="This post compares the differences and characteristics of RabbitMQ and Kafka and suggests suitable use cases." /><link rel="canonical" href="https://youngsu5582.life//posts/rabbitmq-vs-kafka" /><meta property="og:url" content="https://youngsu5582.life//posts/rabbitmq-vs-kafka" /><meta property="og:site_name" content="이영수 개발 블로그" /><meta property="og:image" content="https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-13T21:45:20+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" /><meta property="twitter:title" content="RabbitMQ VS Kafka" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Youngsoo Lee"},"dateModified":"2025-09-13T21:45:20+09:00","datePublished":"2025-09-13T21:45:20+09:00","description":"This post compares the differences and characteristics of RabbitMQ and Kafka and suggests suitable use cases.","headline":"RabbitMQ VS Kafka","image":"https://youngsu5582.life//assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://youngsu5582.life//posts/rabbitmq-vs-kafka"},"url":"https://youngsu5582.life//posts/rabbitmq-vs-kafka"}</script><title>RabbitMQ VS Kafka | 이영수 개발 블로그</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="이영수 개발 블로그"><meta name="application-name" content="이영수 개발 블로그"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-GDSPGC31HX"></script> <script> document.addEventListener('DOMContentLoaded', () => { window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-GDSPGC31HX'); }); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/en/" id="avatar" class="rounded-circle"><img src="/assets/img/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/en/">이영수 개발 블로그</a><p class="site-subtitle fst-italic mb-0">Learning Kata</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/en/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/en/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/en/articles/" class="nav-link"> <i class="fa-fw "></i> <span>ARTICLES</span> </a><li class="nav-item"> <a href="/en/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/en/activities/" class="nav-link"> <i class="fa-fw fas fa-walking"></i> <span>ACTIVITIES</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/youngsu5582" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['joyson5582','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/en/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href="https://www.linkedin.com/in/%EC%98%81%EC%88%98-%EC%9D%B4-b78498347/" aria-label="linkedin" target="_blank" rel="noopener noreferrer" > <i class="fab fa-linkedin"></i> </a> <a href="https://www.rallit.com/hub/resumes/988543/%EC%9D%B4%EC%98%81%EC%88%98" aria-label="resume" target="_blank" rel="noopener noreferrer" > <i class="fas fa-file-alt"></i> </a> <a href="https://comet-pram-809.notion.site/185365707b6580859ec5ec052f2f6730" aria-label="portfolio" target="_blank" rel="noopener noreferrer" > <i class="fas fa-laptop-code"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/en/">Home</a> </span> <span>RabbitMQ VS Kafka</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button><style> .language-switcher { display: flex; gap: 10px; list-style: none; margin: 0; padding: 0; } .language-switcher li a { padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; text-decoration: none; color: #333; background-color: #f0f0f0; } .language-switcher li a:hover { background-color: #e0e0e0; } .language-switcher li .active-lang { /* 현재 활성화된 언어 텍스트 스타일 */ padding: 5px 10px; border: 1px solid #007bff; border-radius: 5px; color: white; background-color: #007bff; cursor: default; }</style><ul class="language-switcher"><li> <a href="https://youngsu5582.life/">한국어</a><li> <span class="active-lang">English</span></ul><search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>RabbitMQ VS Kafka</h1><p class="post-desc fw-light mb-4">This post compares the differences and characteristics of RabbitMQ and Kafka and suggests suitable use cases.</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1757767520" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Sep 13, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" class="popup img-link preview-img shimmer"><img src="/assets/img/thumbnail/2025-09-13-rabbitmq-vs-kafka.png" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3287 words" > <em>18 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">RabbitMQ VS Kafka</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">RabbitMQ VS Kafka</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog> <br><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/rabbitmq/" class="post-tag no-text-decoration" >RabbitMQ</a> <a href="/tags/kafka/" class="post-tag no-text-decoration" >Kafka</a> <a href="/tags/messaging/" class="post-tag no-text-decoration" >Messaging</a> <a href="/tags/asynchronous/" class="post-tag no-text-decoration" >Asynchronous</a></div><div class="content"><p><strong>[Reference Materials]</strong></p><ul><li><strong>Video:</strong> <a href="https://www.youtube.com/watch?v=w8xWTIFU4C8">[10 Minutes Tech Talk] Rockba’s RabbitMQ vs Kafka</a><li><strong>Blog:</strong><ul><li><a href="https://tech.kakao.com/posts/485">Common Message Streaming Platform for Kakao Developers - Kafka</a><li><a href="https://devconnor.tistory.com/159">RABBITMQ IN DEPTH</a><li><a href="https://medium.com/@greg.shiny82/apache-kafka-%E1%84%80%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%A2%E1%86%B8%ED%95%98%E1%84%8E%E1%85%A2-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-343ad84a959b">A Brief Look at Apache Kafka</a></ul></ul><h3 id="introduction"><span class="me-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In modern server application architectures, a messaging system is inevitable.</p><p>The purpose can vary, such as separating logic to improve response speed, ensuring stability and execution, and communicating with other application servers. Many development teams will worry about which technology to use.</p><p>I too started with the question, “Why does our team use RabbitMQ instead of Kafka?” In that process, I found my own answers that I wanted to share.</p><hr /><h2 id="rabbitmq-smart-broker--dumb-consumer"><span class="me-2">RabbitMQ (Smart Broker &amp; Dumb Consumer)</span><a href="#rabbitmq-smart-broker--dumb-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://i.imgur.com/lKkaONm.png" class="popup img-link shimmer"><img src="https://i.imgur.com/lKkaONm.png" alt="700" loading="lazy"></a></p><p>RabbitMQ is a message broker that implements <strong>AMQP (Advanced Message Queuing Protocol)</strong> and also provides the MQTT protocol. The core idea is that the <strong>broker (RabbitMQ) handles most of the routing, message storage, and delivery logic</strong>.</p><blockquote><p>AMQP? Advanced Message Queueing Protocol: A standard protocol for message-oriented middleware. It ensures reliable messaging between different systems and applications.</p><ul><li>Interoperability: Enables communication between systems developed on different languages and platforms.<li>Reliability and Trustworthiness: Ensures messages are delivered without loss, with message acknowledgment (ACK), persistence, and transaction support.<li>Flexible Routing: Routing through Exchange - producers send to Exchange, and Exchange distributes messages to the appropriate queue according to set rules.</ul></blockquote><ul><li><strong>Producer:</strong> Creates messages and sends them to the <strong>Exchange</strong>.<li><strong>Exchange:</strong> A set of routing rules that decides which <strong>Queue</strong> to send the received messages from the Producer to (does not store the message itself).<ul><li><strong>Direct Exchange:</strong> Sends messages to the Queue matching the exact routing key (unicast).<li><strong>Topic Exchange:</strong> Sends messages to the Queue matching a certain pattern in the routing key (multicast).<li><strong>Fanout Exchange:</strong> Sends messages to all queues bound to it (broadcast).<li><strong>Headers Exchange:</strong> Routes based on message header attributes.</ul><li><strong>Queue:</strong> A buffer that stores messages until the consumer retrieves them.<li><strong>Binding:</strong> A rule connecting Exchange and Queue. (“This Exchange sends messages to this Queue according to the routing rules”).<li><strong>Consumer:</strong> Retrieves messages from the Queue and processes them.</ul><blockquote><p><strong>Core Flow:</strong> Producer → Exchange → (Binding Rule) → Queue → Consumer</p></blockquote><h3 id="smart-broker"><span class="me-2">Smart Broker</span><a href="#smart-broker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Complete control over message flow: The broker decides where to send messages and routes them according to Exchange &amp; Binding rules.<li>Tracks consumer state: Continuously tracks whether the consumer is connected to any queue and whether messages are properly processed.<li>Sends messages to consumers: Pushes messages to consumers; consumers adjust the amount they can handle with prefetch.<li>Offers various features: Provides functionalities such as Dead Letter Exchanges, message TTL, priority queues.</ul><h3 id="dumb-consumer"><span class="me-2">Dumb Consumer</span><a href="#dumb-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Focus on simple roles: The consumer connects to a designated queue to receive and process messages and only sends completion signals.<li>No need to know about routing: The consumer doesn’t need to consider how the message arrived in its queue.</ul><p>=&gt; The post office (broker) categorizes and addresses all letters while the mail carrier (consumer) delivers the letters assigned to their zone.</p><h2 id="kafka-dumb-broker--smart-consumer"><span class="me-2">Kafka (Dumb Broker &amp; Smart Consumer)</span><a href="#kafka-dumb-broker--smart-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://i.imgur.com/GoifRDm.png" class="popup img-link shimmer"><img src="https://i.imgur.com/GoifRDm.png" alt="" loading="lazy"></a></p><p>Kafka is a <strong>distributed streaming platform</strong> that treats messages as a <strong>consecutive stream of immutable logs</strong>. The broker stores and manages data, with the consumer handling complex routing logic.</p><ul><li><strong>Broker:</strong> Kafka server instance that stores and manages messages and forms a <strong>Cluster</strong> when gathered with other brokers.<ul><li>Receives messages from Producers, assigns offsets, and stores messages on disk.<li>Responds to partition read requests from consumers and sends messages recorded on disk.<li>One serves as the cluster’s controller, assigning partition responsibilities to each broker and monitoring their proper operation.</ul><li><strong>Cluster:</strong> Composed of multiple brokers, providing data replication, fault tolerance, and high availability.<ul><li>Adding server brokers within the cluster increases the handling of message reception and delivery.<li>Can be performed online without affecting overall system usage (easily scale from a small operation to accommodate large traffic amounts).</ul></ul><p><a href="https://i.imgur.com/rex6S7E.png" class="popup img-link shimmer"><img src="https://i.imgur.com/rex6S7E.png" alt="" loading="lazy"></a></p><ul><li><strong>Topic:</strong> A category or feed name to separate messages. Similar in role to Exchange in RabbitMQ, but directly stores messages.<ul><li>Similar to a DB table or a folder in a file system.<li>A Topic is composed of multiple partitions.</ul><li><strong>Partition:</strong> An <strong>append-only log</strong> that allows for distributed storage of Topic data across multiple brokers and increases throughput.<ul><li><strong>Order within a partition is guaranteed.</strong> - No order guarantee between different partitions.</ul></ul><p><a href="https://i.imgur.com/7m78VEq.png" class="popup img-link shimmer"><img src="https://i.imgur.com/7m78VEq.png" alt="" loading="lazy"></a></p><ul><li><strong>Producer:</strong> Creates messages (records) and sends them to a specific <strong>Topic</strong>.<li><strong>Consumer:</strong> Retrieves and processes messages from the Topic.<ul><li>Subscribes to one or more topics and reads messages in the order they were created, keeping track of message locations via offset on a partition basis.</ul><li><strong>Offset:</strong> A unique serial number (ID) each message has within a partition. Consumers use offsets to track and control where they have read up to.<ul><li><strong>Commit Offset:</strong> An offset confirming the consumer has processed “up to here.”<li><strong>Current Offset:</strong> An offset confirming “where they have read up to.”</ul><li><strong>Consumer Group:</strong> A group of one or more consumers where <strong>each partition of a Topic is allocated to only one consumer within the group</strong>.<ul><li>Each consumer can read messages from different partitions of the topic they are responsible for.<li>Adding consumers extends message consumption performance.</ul></ul><blockquote><p>Adding more consumers than the number of partitions within a topic is meaningless.</p></blockquote><blockquote><p><strong>Core Flow:</strong> Producer → Topic (Partition) → Consumer (Consumer Group)</p></blockquote><h3 id="dumb-broker"><span class="me-2">Dumb Broker</span><a href="#dumb-broker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Concentration on role as high-performance file storage: Brokers quickly add and store messages at the end of topic partitions.<li>No message state tracking: Brokers don’t consider which consumer read which message, just storing them for the set retention period.<li>No complex routing: Brokers store messages in the topic/partition designated by the producer without redistributing messages on their own.</ul><h3 id="smart-consumer"><span class="me-2">Smart Consumer</span><a href="#smart-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Manages reading locations by themselves: Consumers record &amp; manage which part of the topic’s partition they read up to.<li>Actively fetch data: Pull, consumers actively request and fetch data from brokers.<li>Responsible for partition assignment logic: The consumer group’s client library handles decision logic on which partition each consumer will manage.</ul><p>=&gt; A large library (broker) only continuously shelves books (messages) in bookcases (partitions), while readers (consumers) visit the library, remember what they have read (offset), and take the next book to read.</p><blockquote><p>The Gemini analogy is good…!</p></blockquote><h2 id="common-misunderstandings"><span class="me-2">Common Misunderstandings</span><a href="#common-misunderstandings" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>There may be misconceptions that the two systems have similar structures and differ only in performance (or that RabbitMQ is a message system not used), but understanding these concepts clearly is essential to grasp the architectural philosophy differences between the two systems.</p><blockquote><p>Fanout: A pattern where one message is delivered as identical copies to several independent consumers.</p><h3 id="1-kafkas-fanout-is-not-simple-broadcast"><span class="me-2">1. Kafka’s ‘Fanout’ is not Simple Broadcast</span><a href="#1-kafkas-fanout-is-not-simple-broadcast" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></blockquote><p>One of the most common misconceptions is the binary view that <code class="language-plaintext highlighter-rouge">Kafka is Pub/Sub</code> and <code class="language-plaintext highlighter-rouge">RabbitMQ is Work-Queue</code>. In fact, Kafka elegantly integrates these two models through the concept of <strong>Consumer Groups</strong>.</p><ul><li><p><strong>Inter-Group: Pub/Sub (Fanout/Broadcast):</strong> Different <strong>consumer groups</strong> can still independently consume the entire message stream even if they subscribe to the same topic. EX) When there is a topic called <code class="language-plaintext highlighter-rouge">order-events</code>, groups like <code class="language-plaintext highlighter-rouge">Inventory Management Service</code> (Group A) and <code class="language-plaintext highlighter-rouge">Data Analysis Team</code> (Group B) can subscribe to it separately. In this case, both groups can receive and process all messages from <code class="language-plaintext highlighter-rouge">order-events</code> from start to finish independently.</p><li><p><strong>Intra-Group: Work-Queue (Distributed Processing):</strong> Within a <strong>single consumer group</strong>, the story changes. Consumers within the group divide and process the partitions of the topic. (<strong>A partition is assigned to only one consumer within the group</strong>). If there are 4 partitions in a topic and 4 consumers in the group, each consumer will be responsible for one partition and process messages. -&gt; This distributes workloads and increases throughput, matching the ‘work queue’ model.</p></ul><blockquote><p><strong>Core:</strong> Kafka applies both methods through <strong>Consumer Groups</strong>: <strong>data replication/broadcast between different systems</strong> and <strong>distributed task processing within a single system</strong> to maximize throughput.</p></blockquote><h3 id="2-philosophy-on-message-retention-log-or-queue"><span class="me-2">2. Philosophy on Message Retention: ‘Log’ or ‘Queue’?</span><a href="#2-philosophy-on-message-retention-log-or-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The fundamental difference between the two systems lies in how they handle messages.</p><ul><li><p><strong>Kafka: Data is an ‘Immutable Log’</strong> Kafka does <strong>not immediately delete messages once consumed.</strong> Messages are safely stored in the topic until the retention period (e.g., 7 days) or capacity is reached. Consumers only manage an <strong>Offset</strong> that indicates ‘where they have read up to’.</p><ul><li><strong>Message Replay &amp; Time Travel:</strong><ul><li>If a bug occurs in a consumer? Correct the code, then rewind the offset to reprocess all data.<li>Introducing a new system using the messages? Retrieve all events from the beginning of the topic to reconstruct state.</ul><li><strong>Multipurpose Data Hub:</strong> A single event stream can be consumed multiple times by various consumers for different purposes such as real-time dashboards, batch analysis, or model training, at their own pace.</ul><li><p><strong>RabbitMQ: Data is ‘Transient Task’</strong> In traditional RabbitMQ, messages are ‘tasks to be processed.’ Once a consumer retrieves a message and confirms it has been processed <strong>(ack)</strong>, the message is <strong>permanently removed from the queue.</strong></p><p>This method features:</p><ul><li><strong>Optimized for Task Queues:</strong> Efficiently manages tasks like ‘Send an email,’ ‘Generate an image,’ or ‘Optimize an image,’ which do not need to be preserved after being processed.<li><strong>Error-focused Retention:</strong> Message TTL (Time-To-Live) or Dead Letter Exchange (DLX) are functions for when messages are not successfully processed. (Permanent retention is more for exception handling and retry logic, not the core purpose)</ul></ul><blockquote><p><strong>Note:</strong> RabbitMQ, adapting to the times, introduced a new queue type called <strong>Streams</strong>. It provides offset-based non-destructive consumption similar to Kafka, operating like logs. However, RabbitMQ is fundamentally used for the ‘consume-remove’ pattern.</p></blockquote><h3 id="3-rabbitmqs-fanout-relies-on-exchange"><span class="me-2">3. RabbitMQ’s Fanout Relies on ‘Exchange’</span><a href="#3-rabbitmqs-fanout-relies-on-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RabbitMQ fanout operates differently from Kafka’s. The core of RabbitMQ’s routing capabilities lies in the <strong>Exchange</strong>.</p><p>Producers send messages to Exchanges rather than directly to a Queue. Based on its type and rules, the Exchange determines which queue to send messages to.</p><ul><li><strong><code class="language-plaintext highlighter-rouge">fanout</code> Exchange:</strong> Copies and sends messages to <strong>all queues</strong> bound to it. It’s the purest form of broadcast model.<li><strong><code class="language-plaintext highlighter-rouge">topic</code> Exchange:</strong> Matches routing keys with binding patterns using wildcards (<code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">#</code>) and sends messages to queues meeting the criteria (multicast).<li><strong><code class="language-plaintext highlighter-rouge">direct</code> Exchange:</strong> Sends messages only to queues whose binding key exactly matches the routing key (unicast).</ul><blockquote><p><strong>Core:</strong> In RabbitMQ, <strong>smart brokers (Exchange) interpret routing rules intelligently</strong> to distribute messages. In contrast, in Kafka, <strong>producers specify topics</strong>, and <strong>smart consumers group together</strong> to fetch messages.</p></blockquote><hr /><h2 id="rabbitmq-vs-kafka-7-key-comparison-points"><span class="me-2">RabbitMQ vs Kafka: 7 Key Comparison Points</span><a href="#rabbitmq-vs-kafka-7-key-comparison-points" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now, let’s delve deeper into the specific functions and characteristics of the two systems across seven core themes.</p><h3 id="1-message-retention--replay-differing-outlooks-on-data"><span class="me-2">1. Message Retention &amp; Replay: Differing Outlooks on Data</span><a href="#1-message-retention--replay-differing-outlooks-on-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Permanent Log, Infinite Replay Capability</strong></ul><p><a href="https://i.imgur.com/ygKoOrU.png" class="popup img-link shimmer"><img src="https://i.imgur.com/ygKoOrU.png" alt="1000" loading="lazy"></a></p><ul><li><p><strong>Philosophy:</strong> Kafka regards the data as ‘a record of facts’ rather than ‘temporary messages.’ Messages are stored based on <code class="language-plaintext highlighter-rouge">retention.ms</code> (time) or <code class="language-plaintext highlighter-rouge">retention.bytes</code> (capacity) settings.</p><ul><li><strong>Offset Reset (Replay):</strong> Consumers can always enable <code class="language-plaintext highlighter-rouge">auto.offset.reset = 'earliest'</code> to read all events from the beginning of a topic. (This permits infinite possibilities like debugging and recovery, constructing states for new services, A/B testing)<li><strong>Log Compaction:</strong> When set with <code class="language-plaintext highlighter-rouge">cleanup.policy=compact</code>, Kafka retains only the latest value for each <strong>message key</strong> instead of storing all messages of a topic.<blockquote><p>Refer to the <a href="https://docs.confluent.io/kafka/design/log_compaction.html">Kafka Log Compaction</a> documentation.</p></blockquote></ul><li><p><strong>RabbitMQ: Removal-based Task Queue</strong></p><ul><li><strong>Philosophy:</strong> RabbitMQ’s default model places priority on stable task delivery, treating messages as tasks queued for processing, removing them upon successful confirmation <code class="language-plaintext highlighter-rouge">(ack)</code>.<li><strong>Limited Replay:</strong> Once a message is <code class="language-plaintext highlighter-rouge">ack</code>ed, free replay as in Kafka is not viable. To reprocess in case of failure, it either goes to <strong>Dead Letter Exchange (DLX)</strong> or is re-queued via consumer <code class="language-plaintext highlighter-rouge">nack</code> or <code class="language-plaintext highlighter-rouge">reject</code>.<li><strong>Stream Queue (Streams):</strong> Starting RabbitMQ 3.9, stream queue allows operations similar to Kafka’s log operations. This permits non-destructive consumption and fanout distribution of large data. (But these complement RabbitMQ’s traditional model, where Kafka is, unsurprisingly, further matured)</ul></ul><h3 id="2-ordering--parallelism-guarantees-and-trade-offs"><span class="me-2">2. Ordering &amp; Parallelism: Guarantees and Trade-offs</span><a href="#2-ordering--parallelism-guarantees-and-trade-offs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Strict Order Guarantee by Partition</strong><ul><li><strong>Operation:</strong> Within a <strong>single partition</strong>, Kafka guarantees the order of messages absolutely. Messages are logged in the order producers send them, and consumers read in that same order.<li><strong>Trade-off between Parallelism and Order:</strong> Increasing the number of partitions to boost throughput enhances parallel processing while sacrificing order across partitions.<li><strong>Key-based Partitioning:</strong> For crucial order guarantees, <strong>message keys</strong> must be utilized. (For instance, using <code class="language-plaintext highlighter-rouge">user_id</code> as key ensures all <code class="language-plaintext highlighter-rouge">user_id</code> related events are sent to the same partition via hash calculation, ensuring all events are processed sequentially.)</ul><li><strong>RabbitMQ: Uncertainty in Order with Competitive Consumer Environment</strong><ul><li><strong>Default Operation:</strong> While the queue structure is FIFO (First-In-First-Out), when multiple consumers subscribe to a single queue to competitively retrieve messages, <strong>the order of message processing is not ensured.</strong> EX) Consumer A retrieves message 1 and Consumer B retrieves message 2 almost simultaneously and B processes faster, message 2 might be processed before message 1.<li><strong>Order Guarantee Method:</strong> It is possible to force order by activating only one consumer per queue. (This compromises parallelism, reducing productivity)<blockquote><p>Controlling order in RabbitMQ is deceptively tough.. Let messages trigger subsequent messages to ensure order.</p></blockquote></ul></ul><h3 id="3-delivery-guarantees-promises-against-data-loss-and-duplication"><span class="me-2">3. Delivery Guarantees: Promises against Data Loss and Duplication</span><a href="#3-delivery-guarantees-promises-against-data-loss-and-duplication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Supports Exactly-Once Delivery</strong><ul><li><strong>At-least-once:</strong> Default setting allows re-consumption and duplication if failure occurs before consumers confirm and commit offsets.<li><strong>Exactly-Once (EOS):</strong> Supported since Kafka 0.11 through <strong>Idempotent Producer</strong> and <strong>Transactions</strong>.<ul><li><strong>Idempotent Producer:</strong> Eliminates duplicates despite retries by assigning unique IDs to each message.<li><strong>Transactions:</strong> Groups several operations across multiple topic/partitions atomically, enabling a complete Read-Process-Write pattern for EOS.<blockquote><p><strong>Refer to:</strong> <a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/">Exactly-Once Semantics Are Possible: Here’s How Kafka Does It</a></p></blockquote></ul></ul><li><strong>RabbitMQ: Defaults to At-least-once; Exactly-once falls on Application</strong><ul><li><strong>At-least-once:</strong> Consumers facing disconnection after message retrieval and processing before broker acknowledgment may cause re-distribution and duplicates.<li><strong>At-most-once:</strong> Utilizing <code class="language-plaintext highlighter-rouge">auto-ack</code> mode can result in message loss upon processing failure since the broker considers prompt reception as acknowledgment. (Requires careful application)<li><strong>Absence of Exactly-once:</strong> Lacking direct EOS support at protocol/broker level. Application-designated <strong>idempotency logic</strong> must implement EOS.</ul></ul><blockquote><p>But, At-least-once settings are far from bad. It essentially guarantees that specific logic desired by the consumer will occur. Even if one consumer fails, another ensures it is processed correctly. This means another message can fully integrate the process outcome into the DB.</p></blockquote><h3 id="4-flow-control--backpressure-who-sets-the-pace"><span class="me-2">4. Flow Control &amp; Backpressure: Who Sets the Pace?</span><a href="#4-flow-control--backpressure-who-sets-the-pace" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Consumer-led Pull Basis</strong><ul><li><strong>Philosophy:</strong> Consumers retrieve broker data <strong>via Pull</strong>, matching their processing capacity. Data is transmitted only upon consumer’s <code class="language-plaintext highlighter-rouge">poll()</code> method call.<li><strong>Backpressure:</strong> This model, by nature, creates backpressure. When busy, the consumer refrains from <code class="language-plaintext highlighter-rouge">poll()</code>, leaving the data to await at the broker. (Allows fine-tuning of consumption speed via options like <code class="language-plaintext highlighter-rouge">max.poll.records</code> (maximum number of messages fetched at once) and <code class="language-plaintext highlighter-rouge">fetch.min.bytes</code> (minimum data accumulation for response).</ul><li><strong>RabbitMQ: Broker-led Push Basis + Prefetch</strong><ul><li><strong>Philosophy:</strong> The broker <strong>pushes</strong> messages to consumers. This can overwhelm consumers as messages are sent regardless of readiness.<li><strong>Backpressure (Prefetch):</strong> Set the <strong><code class="language-plaintext highlighter-rouge">prefetch</code> value (QoS - Quality of Service)</strong> to resolve this. Limits the number of messages the broker sends to a consumer if they’re already processing a certain number, based on the <code class="language-plaintext highlighter-rouge">prefetch</code> setting.</ul></ul><blockquote><p>Setting RabbitMQ’s <code class="language-plaintext highlighter-rouge">prefetch</code> value is critical for performance and stability. A setting too small incurs frequent network round-trips reducing throughput, while too high risks consuming consumer memory. (This can be crucial when certain domains, like an AI image generation logic using a GPU, require processing one task at a time; <code class="language-plaintext highlighter-rouge">prefetch 1</code> in such case)</p></blockquote><h3 id="5-routingtopology-smart-broker-vs-dumb-broker"><span class="me-2">5. Routing/Topology: ‘Smart Broker’ vs ‘Dumb Broker’</span><a href="#5-routingtopology-smart-broker-vs-dumb-broker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>As the content has been previously covered, I’ll keep it brief.</p></blockquote><ul><li><strong>Kafka: Simple Topology, Smart Client</strong><ul><li><strong>Dumb Broker:</strong> Kafka brokers operate simply, storing messages in the sequentially designated topic partitions by producers (with no complex routing logic).<li><strong>Smart Clients:</strong> Primarily producers decide routing. They decide which topic and key to use to send messages and which partition to target. Consumers determine which topic to subscribe to.</ul><li><strong>RabbitMQ: Flexible Routing, Smart Broker</strong><ul><li><strong>Smart Broker:</strong> RabbitMQ is adept at handling <strong>through Exchanges</strong>. Producers send messages to Exchanges, and the Exchange allocates them to appropriate queues based on configured types (<code class="language-plaintext highlighter-rouge">direct</code>, <code class="language-plaintext highlighter-rouge">topic</code>, <code class="language-plaintext highlighter-rouge">fanout</code>, <code class="language-plaintext highlighter-rouge">headers</code>) and routing rules (<code class="language-plaintext highlighter-rouge">binding</code>).<li><strong>Implementing Complex Workflows:</strong> They can easily construct sophisticated workflows at the broker level to send messages conditionally based on message content or simultaneously to multiple queues. (<strong>Dead Letter Exchange</strong>, <strong>Delayed Message Plugin</strong> can be combined for retry, delayed execution, etc.)</ul></ul><h3 id="6-scalability--high-availability-ha-scale-out-and-data-replication"><span class="me-2">6. Scalability &amp; High Availability (HA): Scale Out and Data Replication</span><a href="#6-scalability--high-availability-ha-scale-out-and-data-replication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Perfect Horizontal Scale via Partitions</strong><ul><li><strong>Design:</strong> Kafka is designed as a distributed system from the start. Topics can be divided into multiple partitions and dispersed across several brokers in a cluster, ensuring horizontal scale-out for reading and writing burden.<li><strong>High Availability (HA):</strong> Each partition has a <strong>Replication Factor</strong>.<ul><li>One partition becomes <strong>Leader</strong>, handling read/write, while the rest are <strong>Followers</strong>, replicating the Leader’s data.<li>In the event of a Leader broker failure, one Follower is automatically elected as the new Leader with minimal service downtime - failover.</ul></ul><li><strong>RabbitMQ: Modern HA through Quorum Queues and Streams</strong><ul><li><strong>Mirrored Queues:</strong> Formerly used mirrored queues, now avoided in favor of Quorum Queues due to Leader-Follower model restrictions and data reliability concerns.<li><strong>Quorum Queues:</strong> Introduced in RabbitMQ 3.8 and operates based on the <strong>Raft consensus algorithm</strong>. It ensures replication to a majority of the cluster nodes, offering reliability significantly above mirrored queues. It is recommended for cases where high availability and data safety are paramount.<li><strong>Stream Queues (Streams):</strong> For demanding throughput and scalability scenarios use. Streams can be sharded across multiple brokers, providing Kafka-like scalability.</ul></ul><blockquote><p>Problems with the Leader-Follower Model?</p><ul><li>Bottleneck in writing: The message must reach leader queues first, waiting for follower replication and acknowledgment.<li>Bottleneck in reading: Consumers can only connect to the leader for message retrieval. =&gt; Publishing and consumption traffic centers on a leader node.</ul></blockquote><h3 id="7-ecosystem--tools-platform-vs-broker"><span class="me-2">7. Ecosystem &amp; Tools: ‘Platform’ vs ‘Broker’</span><a href="#7-ecosystem--tools-platform-vs-broker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Kafka: Data Pipeline Platform</strong> Kafka extends beyond mere messaging brokers and acts as a comprehensive data platform in itself.<ul><li><strong>Kafka Connect:</strong> Framework connecting Kafka with hundreds of systems like databases, S3, Elasticsearch without coding.<li><strong>Kafka Streams / ksqlDB:</strong> Libraries and SQL engine stream-processing and analyzing Kafka topic data in real-time.<li><strong>Schema Registry:</strong> Manages data schemas to ensure data consistency and compatibility.</ul><li><strong>RabbitMQ: Versatile Message Broker</strong> RabbitMQ feels more like a powerful broker tailored for specific purposes.<ul><li><strong>Management UI:</strong> Offers an excellent web UI for visually monitoring and managing queue status, message flow, connections, etc.<li><strong>Federation / Shovel:</strong> Robust plugins to connect brokers across different data centers or environments.<li><strong>Diverse protocol support:</strong> Offers flexibility through plugins supporting various protocols like AMQP 0-9-1, AMQP 1.0, STOMP, MQTT.</ul></ul><h2 id="when-to-choose-what"><span class="me-2">When to Choose What..?</span><a href="#when-to-choose-what" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>Reflective of AI-generated content and considerations on why our team uses RabbitMQ, it naturally might not hold true.</p></blockquote><ul><li><strong>“Do you need to reprocess past data?”</strong><ul><li><strong>Yes → Kafka:</strong> If data replay is necessary for event sourcing, data analysis, introducing new services, then choose Kafka.</ul><li><strong>“Does each message need to be routed differently based on complex criteria?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> If sophisticated routing based on message headers or routing key patterns is essential - Smart Broker.</ul><li><strong>“Is the primary purpose to handle background asynchronous tasks?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> For typical ‘task queue’ scenarios like email dispatch, image processing, etc., RabbitMQ offers a simple, intuitive solution (no need to retain messages).</ul><li><strong>“Do numerous independent services require consuming the same event stream for different purposes?”</strong><ul><li><strong>Yes → Kafka:</strong> Constructing a ‘data hub’ or ‘event backbone’ where multiple teams, services consume the same data at their own pace - through Consumer Group model and message retention policy.</ul><li><strong>“Is ultra-high throughput, like processing hundreds of thousands per second, mandatory?”</strong><ul><li><strong>Yes → Kafka:</strong> Optimized for handling large-scale stream data using disk-based sequential I/O - leverages technologies like Append-Only, OS-level page cache, Zero-Copy.</ul><li><strong>“Do you require per-message TTL, delayed operations, or request-response (RPC) patterns?”</strong><ul><li><strong>Yes → RabbitMQ:</strong> RabbitMQ more maturely supports these advanced messaging patterns through plugins and similar configurations.</ul></ul><h2 id="conclusion"><span class="me-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Don’t fall into the mindset of defaulting to Kafka for message queuing systems. It’s a decision demanding consideration of the company’s infrastructure, team technology, project requirements, and more.</p><p>Reasons why our team opts for RabbitMQ:</p><ul><li>To separate AI generation logic from the API server.<li>Ensuring task completion.<li>Current absence of need for large-scale handling and system setup plus no requirement for replay or storing messages.</ul><p>These points lead us to use RabbitMQ.</p></div><div class="post-tail-wrapper text-muted"><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=RabbitMQ%20VS%20Kafka%20-%20%EC%9D%B4%EC%98%81%EC%88%98%20%EA%B0%9C%EB%B0%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8&url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka&text=RabbitMQ%20VS%20Kafka%20-%20%EC%9D%B4%EC%98%81%EC%88%98%20%EA%B0%9C%EB%B0%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fyoungsu5582.life%2F%2Fposts%2Frabbitmq-vs-kafka" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Linkedin" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/en/posts/rabbitmq-vs-kafka">RabbitMQ VS Kafka - 2025-09-13</a><li class="text-truncate lh-lg"> <a href="/en/posts/partitioning-in-postgresql/">Exploring Partitioning in PostgreSQL - 2025-09-07</a><li class="text-truncate lh-lg"> <a href="/en/posts/ai-tech-usage-summary-thoughts/">Summary of How to Use AI Technology Video and My Thoughts - 2025-08-20</a><li class="text-truncate lh-lg"> <a href="/en/posts/%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-Jackson-%EC%84%A4%EC%A0%95%EB%93%A4-%EC%A0%95%EB%A6%AC/">사용하는 Jackson의 설정 및 기능 정리 - 2025-06-17</a><li class="text-truncate lh-lg"> <a href="/en/posts/%EC%98%88%EC%99%B8-%EA%B9%8A%EA%B2%8C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-%EC%98%88%EC%99%B8-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%8D%98%EC%A7%80%EA%B8%B0/">예외 깊게 살펴보기, 예외 동적으로 던지기 - 2025-05-31</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9A%B0%ED%85%8C%EC%BD%94/">우테코</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%8A%A4%ED%94%84%EB%A7%81/">스프링</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83%ED%97%88%EB%B8%8C/">깃허브</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/git/">git</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83/">깃</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/">코틀린</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/">테스트</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/en/posts/partitioning-in-postgresql/" class="btn btn-outline-primary" aria-label="Older" ><p>Exploring Partitioning in PostgreSQL</p></a><div class="btn btn-outline-primary disabled" aria-label="Newer"><p>-</p></div></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/youngsu5582">이영수</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9A%B0%ED%85%8C%EC%BD%94/">우테코</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%8A%A4%ED%94%84%EB%A7%81/">스프링</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83%ED%97%88%EB%B8%8C/">깃허브</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/git/">git</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EA%B9%83/">깃</a> <a class="post-tag btn btn-outline-primary" href="/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/">코틀린</a> <a class="post-tag btn btn-outline-primary" href="/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/">테스트</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><script> (function () { const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed'); const initTheme = themeMapper[Theme.visualState]; let lang = 'en';if (lang.length > 2 && !lang.startsWith('zh')) { lang = lang.slice(0, 2); } let giscusAttributes = { src: 'https://giscus.app/client.js', 'data-repo': 'youngsu5582/blog', 'data-repo-id': 'R_kgDOOI2eig', 'data-category': 'Post', 'data-category-id': 'DIC_kwDOOI2eis4Cob3Y', 'data-mapping': 'pathname', 'data-strict' : '0', 'data-reactions-enabled': '1', 'data-emit-metadata': '0', 'data-theme': initTheme, 'data-input-position': 'bottom', 'data-lang': lang, 'data-loading': 'lazy', crossorigin: 'anonymous', async: '' }; let giscusNode = document.createElement('script'); Object.entries(giscusAttributes).forEach(([key, value]) => giscusNode.setAttribute(key, value) ); const $footer = document.querySelector('footer'); $footer.insertAdjacentElement("beforebegin", giscusNode); addEventListener('message', (event) => { if (event.source === window && event.data && event.data.id === Theme.ID) { const newTheme = themeMapper[Theme.visualState]; const message = { setConfig: { theme: newTheme } }; const giscus = document.getElementsByClassName('giscus-frame')[0].contentWindow; giscus.postMessage({ giscus: message }, 'https://giscus.app'); } }); })(); </script> <script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
